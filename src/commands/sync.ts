import * as fs from 'node:fs'
import * as path from 'node:path'
import bakeryPackage from '../../package.json'
import { hashContent, hashFile } from '../sync/hash.js'
import {
  createManifest,
  detectChanges,
  getManifestPath,
  isManaged,
  loadManifest,
  saveManifest,
} from '../sync/manifest.js'
import { createTemplateContext, processTemplateDirectory } from '../templates/engine.js'
import { getTemplatesDir, resolveTemplates } from '../templates/loader.js'
import { bold, cyan, dim, green, red, yellow } from '../utils/colors.js'

const BAKERY_VERSION = bakeryPackage.version

interface SyncOptions {
  check: boolean
  force: boolean
}

function printSyncHelp(): void {
  console.log(`
${bold('bakery sync')} - Update project from template

${bold('USAGE:')}
  bakery sync [options]

${bold('OPTIONS:')}
  --check              Dry-run mode, show what would change
  --force              Overwrite files without prompting

${bold('DESCRIPTION:')}
  Updates a Bakery-generated project with the latest template files.
  
  Managed files (configs, CI, etc.) are automatically updated.
  User files (src/, tests/, README.md) prompt before overwriting.

${bold('EXAMPLES:')}
  ${dim('# Check what would be updated')}
  bakery sync --check

  ${dim('# Update project with prompts for user files')}
  bakery sync

  ${dim('# Force update all files')}
  bakery sync --force
`)
}

function parseOptions(args: string[]): SyncOptions {
  return {
    check: args.includes('--check') || args.includes('-c'),
    force: args.includes('--force') || args.includes('-f'),
  }
}

function getTemplateFiles(archetype: string, addons: string[]): Map<string, string> {
  const templates = resolveTemplates(archetype, addons)
  const allFiles = new Map<string, string>()

  const context = createTemplateContext({
    projectName: 'placeholder',
    description: 'placeholder',
    author: '',
    license: 'MIT',
    githubUsername: '',
    archetype,
    apiFramework: undefined,
    webFramework: undefined,
    addons,
  })

  for (const template of templates) {
    const files = processTemplateDirectory(template.path, context)
    for (const [filePath, content] of files) {
      if (filePath !== 'template.json') {
        allFiles.set(filePath, content)
      }
    }
  }

  const templatesDir = getTemplatesDir()
  const archetypePath = path.join(templatesDir, archetype)
  const overlaysPath = path.join(archetypePath, 'overlays')

  if (fs.existsSync(overlaysPath)) {
    const overlayFiles = processTemplateDirectory(overlaysPath, context)
    for (const [filePath, content] of overlayFiles) {
      if (filePath !== 'template.json') {
        allFiles.set(filePath, content)
      }
    }
  }

  return allFiles
}

interface SyncResult {
  updated: string[]
  skipped: string[]
  conflicts: string[]
}

async function performSync(projectDir: string, options: SyncOptions): Promise<SyncResult> {
  const result: SyncResult = {
    updated: [],
    skipped: [],
    conflicts: [],
  }

  const manifestResult = loadManifest(projectDir)
  if (manifestResult.isErr()) {
    console.error(red('No .bakery/manifest.json found. Is this a Bakery project?'))
    console.error(dim('Run bakery sync in a directory that was generated by Bakery.'))
    process.exit(1)
  }

  const manifest = manifestResult.value
  const templateFiles = getTemplateFiles(manifest.archetype, manifest.addons)

  console.log(`\n${bold('Syncing project from template...')}`)
  console.log(`${dim('Archetype:')} ${manifest.archetype}`)
  console.log(
    `${dim('Addons:')} ${manifest.addons.length > 0 ? manifest.addons.join(', ') : 'none'}`,
  )
  console.log('')

  const changesResult = detectChanges(projectDir, manifest)
  if (changesResult.isErr()) {
    console.error(red(`Failed to detect changes: ${changesResult.error.message}`))
    process.exit(1)
  }

  const localChanges = changesResult.value
  const modifiedLocally = new Set(
    localChanges.filter((c) => c.type === 'modified').map((c) => c.path),
  )

  for (const [filePath, templateContent] of templateFiles) {
    const fullPath = path.join(projectDir, filePath)
    const fileExists = fs.existsSync(fullPath)
    const managed = isManaged(filePath)
    const locallyModified = modifiedLocally.has(filePath)

    if (options.check) {
      if (!fileExists) {
        console.log(`${green('+')} ${filePath} ${dim('(new file)')}`)
        result.updated.push(filePath)
      } else if (managed) {
        const currentHashResult = hashFile(fullPath)
        const templateHash = hashContent(templateContent)
        if (currentHashResult.isOk() && templateHash !== currentHashResult.value) {
          console.log(`${yellow('~')} ${filePath} ${dim('(managed, will update)')}`)
          result.updated.push(filePath)
        } else {
          result.skipped.push(filePath)
        }
      } else if (locallyModified) {
        console.log(`${red('!')} ${filePath} ${dim('(user file, modified locally)')}`)
        result.conflicts.push(filePath)
      } else {
        result.skipped.push(filePath)
      }
      continue
    }

    if (!fileExists) {
      const dir = path.dirname(fullPath)
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true })
      }
      fs.writeFileSync(fullPath, templateContent)
      console.log(`${green('+')} ${filePath}`)
      result.updated.push(filePath)
    } else if (managed || options.force) {
      fs.writeFileSync(fullPath, templateContent)
      console.log(`${yellow('~')} ${filePath}`)
      result.updated.push(filePath)
    } else if (locallyModified) {
      console.log(`${dim('-')} ${filePath} ${dim('(skipped, locally modified)')}`)
      result.skipped.push(filePath)
    } else {
      result.skipped.push(filePath)
    }
  }

  if (!options.check) {
    const newManifestResult = createManifest(projectDir, {
      bakeryVersion: BAKERY_VERSION,
      archetype: manifest.archetype,
      addons: manifest.addons,
    })

    if (newManifestResult.isOk()) {
      const saveResult = saveManifest(projectDir, newManifestResult.value)
      if (saveResult.isErr()) {
        console.error(red(`Failed to update manifest: ${saveResult.error.message}`))
      }
    }
  }

  return result
}

export async function handleSyncCommand(args: string[]): Promise<void> {
  if (args.includes('--help') || args.includes('-h')) {
    printSyncHelp()
    return
  }

  const options = parseOptions(args)
  const projectDir = process.cwd()

  const manifestPath = getManifestPath(projectDir)
  if (!fs.existsSync(manifestPath)) {
    console.error(red('No .bakery/manifest.json found in current directory.'))
    console.error('')
    console.error('This command must be run in a Bakery-generated project.')
    console.error(`The project must have a ${cyan('.bakery/manifest.json')} file.`)
    process.exit(1)
  }

  const result = await performSync(projectDir, options)

  console.log('')
  if (options.check) {
    console.log(bold('Sync check complete:'))
    console.log(`  ${green('Would update:')} ${result.updated.length} files`)
    console.log(`  ${yellow('Conflicts:')} ${result.conflicts.length} files`)
    console.log(`  ${dim('Unchanged:')} ${result.skipped.length} files`)

    if (result.conflicts.length > 0) {
      console.log('')
      console.log(yellow('Files with local modifications:'))
      for (const file of result.conflicts) {
        console.log(`  ${file}`)
      }
      console.log('')
      console.log(dim('Use --force to overwrite these files.'))
    }
  } else {
    console.log(bold('Sync complete:'))
    console.log(`  ${green('Updated:')} ${result.updated.length} files`)
    console.log(`  ${dim('Skipped:')} ${result.skipped.length} files`)
  }
}
