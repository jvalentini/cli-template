import { Context, Effect, Layer } from 'effect';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';

export interface Config {
  version: string;
  debug: boolean;
  logLevel: 'debug' | 'info' | 'warn' | 'error';
}

const defaultConfig: Config = {
  version: '0.1.0',
  debug: false,
  logLevel: 'info',
};

export class ConfigService extends Context.Tag('ConfigService')<
  ConfigService,
  {
    readonly load: () => Effect.Effect<Config>;
    readonly save: (config: Config) => Effect.Effect<void>;
    readonly getConfigPath: () => Effect.Effect<string>;
  }
>() {}

const getConfigDir = (): string => {
  const configDir = path.join(os.homedir(), '.<%= projectName %>');
  if (!fs.existsSync(configDir)) {
    fs.mkdirSync(configDir, { recursive: true });
  }
  return configDir;
};

const getConfigFilePath = (): string => {
  return path.join(getConfigDir(), 'config.json');
};

export const ConfigServiceLive = Layer.succeed(
  ConfigService,
  ConfigService.of({
    load: () =>
      Effect.try({
        try: () => {
          const configPath = getConfigFilePath();
          if (fs.existsSync(configPath)) {
            const content = fs.readFileSync(configPath, 'utf8');
            return { ...defaultConfig, ...JSON.parse(content) } as Config;
          }
          return defaultConfig;
        },
        catch: () => defaultConfig,
      }),

    save: (config) =>
      Effect.try({
        try: () => {
          const configPath = getConfigFilePath();
          fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
        },
        catch: (error) => {
          throw new Error(`Failed to save config: ${error}`);
        },
      }),

    getConfigPath: () => Effect.succeed(getConfigFilePath()),
  })
);
